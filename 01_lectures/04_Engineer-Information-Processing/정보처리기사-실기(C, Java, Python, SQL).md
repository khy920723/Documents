# C
## 1.1 프로그래밍 및 C Language & 컴파일러 사용법
- 컴파일: 
  - 코드화된 문자 -> 명령들의 집합 (컴파일 실행은 OS)
- 프로그래밍 기본 절차:
  - 저장공간 확보 -> 입력 -> 처리 -> 출력
- C특징:
  - 이식성, 함수 사용, System Programming 가능
- 표준화 과정:
  - K&R C(1975) -> ANSI C(1989) -> C99(1999) -> C11(2011)
- 작성 순서:
  - 소스파일 작성 -> 컴파일 -> 실행
- 소스파일:
  - 아스키 코드에 따라 저장된 파일
- 실행파일:
  - 기계어 형태의 파일(컴퓨터가 이해) 
- IDE 컴파일러 사용법:
  - 프로젝트 생성 -> 소스파일 추가 -> 빌드 -> 실행
## 2.1 C의 기본 형태와 데이터 출력
- Startup Code: 
  - OS의 영향을 받아 프로그램에서 처음 시작하는 부분
  - 컴파일러가 스타트업 코드를 붙여서 실행
  - 코드 내용은 main 함수 실행 관련
  - main에서 return 0을 하게 되면, 제어권을 다시 스타트업 코드에 줌(스타트업 코드는 OS에게 제어권 반납하며 프로그램 종료)
- 전처리기와 지시자
  - 지시자: include...
  - 전처리기: 지시자 등을 처리
- C 프로그래밍 기본 형태
  - 문장의 끝 세미콜론
  - 주석은 //와 /**/ 사용
- printf 함수
  - 문자열 출력(기본)
  - 제어문자 출력(\n, \r, \t, \b, \a)
## 2.2 상수와 데이터 표현법
- 상수: 변하지 않는 수
- 정수형 상수
  - 4byte(32bit)
    - 10 -> 00001010(2)
    - -10 -> 절대값(10)의 1의 보수(0, 1 반전) 마지막 bit에 1을 더해 2의 보수 생성 -> 11110110
    - 맨 앞의 0은 MSB(Most Significant Bit)
      - MSB가 1인 경우 음수
    - 맨 뒤의 0은 LSB(Least Significant Bit)
    - 4byte로 표기 가능한 수들은 그대로 헤주지만, 2의 32승 -1 값(4294567295)까지는 자동으로 8byte로 변환하여 줌.
      - 강제로 8byte 사용을 위해선 숫자 뒤에 LL을 붙임(ex. 10LL)
  - 0~9와 +, - 연산으로 표기되는 것들
  - 8진수: 0~7 (정수 8일 때, 8진수 표기는 10, C코드로는 010)
  - 16진수: 0~9~a~f (정수 12일 때, 16진수 표기는 c, 코드로는 0xc)
    > 8진수, 16진수의 코드 표기와 같은 것들을 접두어라고 함
- 실수형 상수
  - 8byte
    - 6.5 -> 110.1
    - 6.4 -> 110.011001100110....
      - 실수를 이진수로 바꾸기 위해서는 (1)부호, (2)지수, (3)유효숫자를 구해 64bit에 저장하는데, 이 때 잘려서 사라진 bit값으로 인해 앱실론(epsilon) 오차가 생김
  - 0~9와 +, - 연산과 .(소숫점)으로 표기되는 것들
  - 지수 표기법: 
    - 0.00315 -> 3.15 * 10의 -5승 -> 3.15e-5
- 문자 상수
  - 'A'
  - 아스키 코드값으로 변환되므로 문자 = 정수 개념(4byte) -> 하지만 실제 의미 있는 값은 마지막 아스키 코드값이 저장된 byte만 있으므로 사실상 1byte(C++, C는 4byte 처리)
- 문자열 상수
  - "Apple"
  - "A"라면 문자열 상수임
  - 문자와 같이 아스키 코드값으로 변환되지만, 맨 앞 byte만 숫자관련 값을 저장하고 나머지 byte 하나는 문자열 순서에 관한 값으로 저장(2byte)
## 3.1 변수
- 쓰레기값
  - 변수 선언 시, 저장 공간을 할당 받으며 해당 공간에 이전에 저장되어 있던 값들을 지칭(어떤 값이 남아있는지 모름)-> 따라서 초기화 필요
- b = a -> a의 값 복사